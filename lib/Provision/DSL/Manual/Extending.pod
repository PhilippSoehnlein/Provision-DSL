=head1 NAME

Provision::DSL::Manual::Extending - how to extend Provision::DSL

=head1 ENTITIES

Creating new entities can be very simple. In order to maintain the whole
system behind working you need to know a few things:

=over

=item state

Every Entity must be able to report its state. The state is represented by one
of three words: C<missing>, C<outdated> or C<current>. An entity derived from
L<Entity|Provision::DSL::Entity> or
L<Entity::Compound|Provision::DSL::Entity::Compound> must report its state
using C<<< $self->set_state('outdated') >>>. 
A typical state routine looks like this:

    before state => sub {
        my $self = shift;

        # conditions, conditions, conditions
        $self->set_state('missing');
    };

If a Role or Trait does a state-check it must report its state using
C<<< $self->set_state('missing') >>>.

    before state => sub {
        my $self = shift;
    
        # conditions, conditions, conditions
        $self->add_state('missing');
    };

The reason for this is the weight of a state depending on the origin. The
Entity object has more weight. If the main entity reports a C<missing> state,
it will remain and can never get improved by a role or other depending entity.
Otherwise depending roles may degrade a C<current> entity to C<outdated> if
any of them is not current.

=item name

When using the dsl to define a provisioning, an entity is created or 
referenced by a C<name> which is stored in the object's attribute "name".
However, most entities behave more natural if they use correctly named
attributes for their purposes. In order to still allow an easy creation of
entities using clde like C<<< Entity some_name => { ... } >>>. To allow
this mechanism to happen, you will need to define one attribute like this:

    # assuming that 'foo' is the attribute you like
    has foo => ( is => 'lazy' );
    sub _build_foo { $_[0]->name }

=item create, change, remove

depending on the entity's state and the content of the C<wanted> flag,
one of these 3 methods will get called. A typical implementation might look
like this:

    before create => sub { ... };
    before change => sub { ... };
    after  remove => sub { ... };

=back

=head2 Simple entities

### inherit from Provision::DSL::Entity

=head2 Entities with roles

### add as many roles as you like
### role may have attributes
### role may expand state and merge role-state with object-state
### after create/change, before remove

=head2 Compound entities

### inherit from Provision::DSL::Entity::Compound
### dynamic list of children
### state is determined automatically by accumulating childrens' states
### state may be overloaded: around state
### Roles may be used

=head2 Different operating systems

### create Provision::DSL::Entity::_((OS))::YourEntity

=head2 Individual entities

Each single entity may be extended with a trait. Simply add a new attribute
which is typically not supported by the entity.

    Dir '/path/to/x' => (
        restore => 'ftp://user:pass@ftp.domain.com/foo',
    );

Next, define a trait "Restore" in one of the namespaces. (Replace "Attribute")
with "Restore", "Entity" with "Dir" and set your OS right. The following
namespaces are checked in this order where the first match begins. This allows
os-dependent, entity-dependent or universal traits, just as you like.

=over

=item Provision::DSL::TraitFor::((Entity))::_((OS))::((Attribute))

=item Provision::DSL::TraitFor::((Entity))::((Attribute))

=item Provision::DSL::TraitFor::_((OS))::((Attribute))

=item Provision::DSL::TraitFor::((Attribute))

=back

The trait can handle thing in a similar way as a role but is applied to
the instance of the Dir-Object in the moment the provision is running. After
applying all traits, every superfluous attribute value is handed over
to a equal-named accessor method, if possible.

=head1 RESOURCES

### inherit from Provision::DSL::Source
### like entities, construct one attribute lazily from attribute 'name'
### implement _build_content which may die if content does not make sense

=head1 AUTHOR

Wolfgang Kinkeldei, E<lt>wolfgang@kinkeldei.deE<gt>

=head1 LICENSE

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut